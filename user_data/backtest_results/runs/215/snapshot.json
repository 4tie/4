{
  "version": 1,
  "createdAt": "2026-02-07T03:15:32.677Z",
  "backtestId": 215,
  "strategyPath": "user_data/strategies/ll.py",
  "strategyContent": "# MultiMa Strategy V2 - Enhanced\n# Author: @Mablue (Masoud Azizi)\n# github: https://github.com/mablue/\n\n# --- Do not remove these libs ---\nfrom freqtrade.strategy import IntParameter, IStrategy, CategoricalParameter\nfrom pandas import DataFrame\n\n# --------------------------------\n\n# Add your lib to import here\nimport talib.abstract as ta\nimport freqtrade.vendor.qtpylib.indicators as qtpylib\nfrom functools import reduce\nimport pandas as pd\nfrom numpy import nanmean\n\n\nclass ll(IStrategy):\n    \"\"\"\n    MultiMa Strategy - Enhanced with RSI confirmation and trend filters.\n    Uses multiple EMA crossovers for entry and exit signals.\n    \"\"\"\n\n    INTERFACE_VERSION: int = 3\n\n    # Buy hyperspace params:\n    buy_params = {\n        \"buy_ma_count\": 4,\n        \"buy_ma_gap\": 15,\n        \"buy_rsi_threshold\": 65,\n        \"buy_enable_rsi\": True,\n    }\n\n    # Sell hyperspace params:\n    sell_params = {\n        \"sell_ma_count\": 12,\n        \"sell_ma_gap\": 68,\n        \"sell_rsi_threshold\": 35,\n        \"sell_enable_rsi\": True,\n    }\n\n    # ROI table:\n    minimal_roi = {\n        \"0\": 0.523,\n        \"1553\": 0.123,\n        \"2332\": 0.076,\n        \"3169\": 0\n    }\n\n    # Stoploss:\n    stoploss = -0.25\n    trailing_stop = True\n    trailing_stop_positive = 0.05\n    trailing_stop_positive_offset = 0.01\n    trailing_only_offset_is_reached = True\n\n    # Timeframe\n    timeframe = \"4h\"\n\n    # Strategy parameters\n    count_max = 20\n    gap_max = 100\n\n    # Buy parameters\n    buy_ma_count = IntParameter(1, count_max, default=7, space=\"buy\")\n    buy_ma_gap = IntParameter(5, gap_max, default=15, space=\"buy\")\n    buy_rsi_threshold = IntParameter(30, 70, default=65, space=\"buy\")\n    buy_enable_rsi = CategoricalParameter([True, False], default=True, space=\"buy\")\n\n    # Sell parameters\n    sell_ma_count = IntParameter(1, count_max, default=12, space=\"sell\")\n    sell_ma_gap = IntParameter(20, gap_max, default=68, space=\"sell\")\n    sell_rsi_threshold = IntParameter(20, 50, default=35, space=\"sell\")\n    sell_enable_rsi = CategoricalParameter([True, False], default=True, space=\"sell\")\n\n    # Protection parameters\n    cooldown_after_buy = CategoricalParameter([True, False], default=True)\n    cooldown_period = IntParameter(1, 12, default=3, space=\"protection\")\n\n    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n        \"\"\"Calculate all indicators needed for the strategy.\"\"\"\n        # Calculate periods from buy/sell parameters\n        periods = set()\n        for ma_count in range(1, int(self.buy_ma_count.value) + 1):\n            periods.add(ma_count * int(self.buy_ma_gap.value))\n        for ma_count in range(1, int(self.sell_ma_count.value) + 1):\n            periods.add(ma_count * int(self.sell_ma_gap.value))\n\n        # Filter and sort periods\n        periods = sorted([p for p in periods if p > 1])\n\n        # Generate EMA columns\n        new_cols = {}\n        for p in periods:\n            col_name = f\"ema_{p}\"\n            if col_name not in dataframe.columns:\n                new_cols[col_name] = ta.EMA(dataframe, timeperiod=int(p))\n\n        # Add new columns\n        if new_cols:\n            dataframe = pd.concat([dataframe, pd.DataFrame(new_cols)], axis=1)\n\n        # RSI indicator\n        dataframe[\"rsi\"] = ta.RSI(dataframe, timeperiod=14)\n\n        # RSI-based indicators\n        dataframe[\"rsi_ma\"] = ta.SMA(dataframe[\"rsi\"], timeperiod=7)\n\n        # Bollinger Bands for volatility filter\n        dataframe[\"bb_upper\"], dataframe[\"bb_middle\"], dataframe[\"bb_lower\"] = ta.BBANDS(\n            dataframe, timeperiod=20, nbdevup=2, nbdevdn=2\n        )\n        dataframe[\"bb_width\"] = (dataframe[\"bb_upper\"] - dataframe[\"bb_lower\"]) / dataframe[\"bb_middle\"]\n\n        # ATR for volatility measurement\n        dataframe[\"atr\"] = ta.ATR(dataframe, timeperiod=14)\n\n        # Volume indicators\n        dataframe[\"volume_ma\"] = ta.SMA(dataframe[\"volume\"], timeperiod=20)\n        dataframe[\"volume_ratio\"] = dataframe[\"volume\"] / dataframe[\"volume_ma\"]\n\n        # Trend strength using ADX\n        dataframe[\"adx\"] = ta.ADX(dataframe, timeperiod=14)\n        dataframe[\"plus_di\"] = ta.PLUS_DI(dataframe, timeperiod=14)\n        dataframe[\"minus_di\"] = ta.MINUS_DI(dataframe, timeperiod=14)\n\n        # Cooldown indicator\n        dataframe[\"cooldown\"] = 0\n\n        print(f\"Processing: {metadata['pair']}\")\n\n        return dataframe\n\n    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n        \"\"\"\n        Buy signal logic:\n        1. EMA crossover: shorter EMA below longer EMA (bullish setup)\n        2. RSI confirmation (optional)\n        3. Price above middle Bollinger Band\n        4. Strong trend (ADX > 20)\n        \"\"\"\n        dataframe[\"buy\"] = 0\n\n        # EMA crossover conditions\n        ema_conditions = []\n        for ma_count in range(1, self.buy_ma_count.value + 1):\n            key = ma_count * self.buy_ma_gap.value\n            past_key = (ma_count - 1) * self.buy_ma_gap.value\n            if past_key > 1 and f\"ema_{key}\" in dataframe.columns and f\"ema_{past_key}\" in dataframe.columns:\n                ema_conditions.append(dataframe[f\"ema_{key}\"] < dataframe[f\"ema_{past_key}\"])\n\n        # RSI condition (optional)\n        rsi_condition = True\n        if self.buy_enable_rsi.value:\n            rsi_condition = dataframe[\"rsi\"] < self.buy_rsi_threshold.value\n\n        # Trend condition (ADX > 20 indicates trending market)\n        trend_condition = dataframe[\"adx\"] > 20\n\n        # Volatility condition (not too wide BB)\n        volatility_condition = dataframe[\"bb_width\"] < 0.1\n\n        # Volume condition (reasonable volume)\n        volume_condition = dataframe[\"volume_ratio\"] > 0.5\n\n        # Combine all conditions\n        if ema_conditions:\n            all_conditions = ema_conditions + [\n                rsi_condition,\n                trend_condition,\n                volatility_condition,\n                volume_condition,\n            ]\n            dataframe.loc[\n                reduce(lambda x, y: x & y, all_conditions),\n                'buy'\n            ] = 1\n\n        return dataframe\n\n    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n        \"\"\"\n        Sell signal logic:\n        1. Reverse EMA crossover: shorter EMA above longer EMA\n        2. RSI confirmation (optional)\n        3. Price below middle Bollinger Band\n        4. Weakening trend\n        \"\"\"\n        dataframe[\"sell\"] = 0\n\n        # Reverse EMA crossover conditions\n        ema_conditions = []\n        for ma_count in range(1, self.sell_ma_count.value + 1):\n            key = ma_count * self.sell_ma_gap.value\n            past_key = (ma_count - 1) * self.sell_ma_gap.value\n            if past_key > 1 and f\"ema_{key}\" in dataframe.columns and f\"ema_{past_key}\" in dataframe.columns:\n                ema_conditions.append(dataframe[f\"ema_{key}\"] > dataframe[f\"ema_{past_key}\"])\n\n        # RSI condition (optional)\n        rsi_condition = True\n        if self.sell_enable_rsi.value:\n            rsi_condition = dataframe[\"rsi\"] > self.sell_rsi_threshold.value\n\n        # Trend weakening (plus_di crossing below minus_di)\n        trend_condition = dataframe[\"plus_di\"] < dataframe[\"minus_di\"]\n\n        # Price below middle Bollinger Band\n        bb_condition = dataframe[\"close\"] < dataframe[\"bb_middle\"]\n\n        # Combine all conditions\n        if ema_conditions:\n            all_conditions = ema_conditions + [\n                rsi_condition,\n                trend_condition,\n                bb_condition,\n            ]\n            dataframe.loc[\n                reduce(lambda x, y: x & y, all_conditions),\n                'sell'\n            ] = 1\n\n        return dataframe\n\n    def custom_stoploss(\n        self, dataframe: DataFrame, metadata: dict, init_stoploss: float, current_profit: float, **kwargs\n    ) -> float:\n        \"\"\"\n        Dynamic stoploss based on ATR and profit level.\n        Tightens stop as profit increases.\n        \"\"\"\n        atr_percent = dataframe[\"atr\"].iloc[-1] / dataframe[\"close\"].iloc[-1]\n\n        # Base stoploss with ATR buffer\n        sl = init_stoploss - atr_percent\n\n        # Tighten stop as profit grows\n        if current_profit > 0.15:\n            sl = max(sl, -0.08)  # Tighten to 8%\n        elif current_profit > 0.10:\n            sl = max(sl, -0.10)  # Tighten to 10%\n        elif current_profit > 0.05:\n            sl = max(sl, -0.15)  # Tighten to 15%\n\n        return sl\n\n    def custom_exit(\n        self, dataframe: DataFrame, metadata: dict, side: str, **kwargs\n    ) -> tuple[DataFrame, DataFrame]:\n        \"\"\"\n        Custom exit rules for additional profit taking.\n        \"\"\"\n        buy_exit = DataFrame({\"exit_tag\": [None] * len(dataframe)})\n        sell_exit = DataFrame({\"exit_tag\": [None] * len(dataframe)})\n\n        # Take profit at specific ROI levels\n        roi_targets = [\n            (0.08, \"take_profit_8pct\"),\n            (0.15, \"take_profit_15pct\"),\n            (0.25, \"take_profit_25pct\"),\n        ]\n\n        for profit_threshold, tag in roi_targets:\n            if side == \"long\":\n                mask = dataframe[\"close\"] > dataframe[\"open\"] * (1 + profit_threshold)\n            else:\n                mask = dataframe[\"close\"] < dataframe[\"open\"] * (1 - profit_threshold)\n\n            if side == \"long\":\n                buy_exit.loc[mask, \"exit_tag\"] = tag\n            else:\n                sell_exit.loc[mask, \"exit_tag\"] = tag\n\n        return buy_exit, sell_exit\n\n    def confirm_trade_entry(self, pair: str, order_type: str, amount: float, rate: float, time_in_force: str, current_time, current_rate, current_profit, **kwargs) -> bool:\n        \"\"\"\n        Final confirmation before placing buy order.\n        \"\"\"\n        # Skip if cooldown is active\n        if self.cooldown_after_buy.value:\n            # Check recent trades for this pair\n            trades = self.get_recent_trades(pair)\n            if trades:\n                last_trade = trades[-1]\n                from freqtrade.constants import LONGEST_INTERVAL\n                from datetime import datetime, timedelta\n\n                if isinstance(current_time, datetime):\n                    trade_time = last_trade[\"open_timestamp\"]\n                    cooldown_end = trade_time + timedelta(hours=self.cooldown_period.value)\n                    if current_time < cooldown_end:\n                        return False\n\n        return True\n",
  "configPath": "user_data/config.json",
  "configContent": "{\n  \"$schema\": \"https://schema.freqtrade.io/schema.json\",\n  \"strategy\": \"UniversalMACD\",\n  \"max_open_trades\": 8,\n  \"stake_currency\": \"USDT\",\n  \"stake_amount\": \"unlimited\",\n  \"tradable_balance_ratio\": 0.99,\n  \"fiat_display_currency\": \"USD\",\n  \"dry_run\": true,\n  \"dry_run_wallet\": 50,\n  \"trading_mode\": \"spot\",\n  \"timeframe\": \"5m\",\n  \"cancel_open_orders_on_exit\": true,\n  \"use_exit_signal\": true,\n  \"entry_pricing\": {\n    \"price_side\": \"same\",\n    \"use_order_book\": true,\n    \"order_book_top\": 1,\n    \"price_last_balance\": 0,\n    \"check_depth_of_market\": {\n      \"enabled\": false,\n      \"bids_to_ask_delta\": 1\n    }\n  },\n  \"exit_pricing\": {\n    \"price_side\": \"other\",\n    \"use_order_book\": true,\n    \"order_book_top\": 1\n  },\n  \"exchange\": {\n    \"name\": \"binance\",\n    \"key\": \"\",\n    \"secret\": \"\",\n    \"method\": \"StaticPairList\",\n    \"pair_whitelist\": [\n      \"BTC/USDT\",\n      \"ETH/USDT\",\n      \"BNB/USDT\",\n      \"SOL/USDT\",\n      \"ADA/USDT\",\n      \"XRP/USDT\",\n      \"DOT/USDT\",\n      \"DOGE/USDT\",\n      \"AVAX/USDT\",\n      \"LINK/USDT\",\n      \"MATIC/USDT\",\n      \"LTC/USDT\",\n      \"TRX/USDT\",\n      \"UNI/USDT\",\n      \"ATOM/USDT\",\n      \"XLM/USDT\",\n      \"ETC/USDT\",\n      \"BCH/USDT\",\n      \"NEAR/USDT\",\n      \"FIL/USDT\",\n      \"APT/USDT\",\n      \"ARB/USDT\",\n      \"OP/USDT\",\n      \"ICP/USDT\",\n      \"ALGO/USDT\",\n      \"AAVE/USDT\",\n      \"SAND/USDT\",\n      \"MANA/USDT\",\n      \"FTM/USDT\",\n      \"EGLD/USDT\",\n      \"RUNE/USDT\",\n      \"INJ/USDT\",\n      \"GALA/USDT\",\n      \"HBAR/USDT\",\n      \"VET/USDT\"\n    ],\n    \"pair_blacklist\": [],\n    \"ccxt_config\": {\n      \"enableRateLimit\": true,\n      \"timeout\": 120000\n    },\n    \"ccxt_async_config\": {\n      \"enableRateLimit\": true,\n      \"timeout\": 120000\n    },\n    \"fees\": {\n      \"maker\": 0.001,\n      \"taker\": 0.001\n    }\n  },\n  \"pairlists\": [\n    {\n      \"method\": \"StaticPairList\",\n      \"pair_whitelist\": [\n        \"BTC/USDT\",\n        \"ETH/USDT\",\n        \"BNB/USDT\",\n        \"SOL/USDT\",\n        \"ADA/USDT\",\n        \"XRP/USDT\",\n        \"DOT/USDT\",\n        \"DOGE/USDT\",\n        \"AVAX/USDT\",\n        \"LINK/USDT\",\n        \"MATIC/USDT\",\n        \"LTC/USDT\",\n        \"TRX/USDT\",\n        \"UNI/USDT\",\n        \"ATOM/USDT\",\n        \"XLM/USDT\",\n        \"ETC/USDT\",\n        \"BCH/USDT\",\n        \"NEAR/USDT\",\n        \"FIL/USDT\",\n        \"APT/USDT\",\n        \"ARB/USDT\",\n        \"OP/USDT\",\n        \"ICP/USDT\",\n        \"ALGO/USDT\",\n        \"AAVE/USDT\",\n        \"SAND/USDT\",\n        \"MANA/USDT\",\n        \"FTM/USDT\",\n        \"EGLD/USDT\",\n        \"RUNE/USDT\",\n        \"INJ/USDT\",\n        \"GALA/USDT\",\n        \"HBAR/USDT\",\n        \"VET/USDT\"\n      ],\n      \"pair_blacklist\": []\n    }\n  ],\n  \"telegram\": {\n    \"enabled\": false,\n    \"token\": \"\",\n    \"chat_id\": \"\"\n  },\n  \"api_server\": {\n    \"enabled\": true,\n    \"listen_ip_address\": \"127.0.0.1\",\n    \"listen_port\": 8080,\n    \"verbosity\": \"error\",\n    \"enable_openapi\": true,\n    \"jwt_secret_key\": \"obEY6PIEi06ZZKzvRpG4QhweSK58gf-8Xpn\",\n    \"ws_token\": \"MweZ3_n4wXmLbZxVtQCbEfCBT1D_ox\",\n    \"CORS_origins\": [\n      \"\"\n    ],\n    \"username\": \"\",\n    \"password\": \"\"\n  },\n  \"bot_name\": \"4tiee\",\n  \"initial_state\": \"running\",\n  \"force_entry_enable\": true,\n  \"internals\": {\n    \"process_throttle_secs\": 5\n  },\n  \"dataformat_ohlcv\": \"json\",\n  \"dataformat_trades\": \"feather\",\n  \"freqaimodel\": \"XGBoostRegressor\",\n  \"freqai\": {\n    \"enabled\": false,\n    \"identifier\": \"qs_v9_scalp_5m1h_l2\",\n    \"write_metrics_to_disk\": false,\n    \"purge_old_models\": 2,\n    \"conv_width\": 1,\n    \"train_period_days\": 21,\n    \"backtest_period_days\": 3,\n    \"live_retrain_hours\": 12,\n    \"expiration_hours\": 0,\n    \"save_backtest_models\": false,\n    \"fit_live_predictions_candles\": 120,\n    \"data_kitchen_thread_count\": 0,\n    \"activate_tensorboard\": false,\n    \"wait_for_training_iteration_on_reload\": true,\n    \"continual_learning\": false,\n    \"keras\": false,\n    \"override_exchange_check\": false,\n    \"feature_parameters\": {\n      \"include_corr_pairlist\": [\n        \"BTC/USDT\",\n        \"ETH/USDT\",\n        \"BNB/USDT\",\n        \"SOL/USDT\",\n        \"ADA/USDT\",\n        \"XRP/USDT\",\n        \"DOT/USDT\",\n        \"DOGE/USDT\",\n        \"AVAX/USDT\",\n        \"LINK/USDT\",\n        \"MATIC/USDT\",\n        \"LTC/USDT\",\n        \"TRX/USDT\",\n        \"UNI/USDT\",\n        \"ATOM/USDT\",\n        \"XLM/USDT\",\n        \"ETC/USDT\",\n        \"BCH/USDT\",\n        \"NEAR/USDT\",\n        \"FIL/USDT\",\n        \"APT/USDT\",\n        \"ARB/USDT\",\n        \"OP/USDT\",\n        \"ICP/USDT\",\n        \"ALGO/USDT\",\n        \"AAVE/USDT\",\n        \"SAND/USDT\",\n        \"MANA/USDT\",\n        \"FTM/USDT\",\n        \"EGLD/USDT\",\n        \"RUNE/USDT\",\n        \"INJ/USDT\",\n        \"GALA/USDT\",\n        \"HBAR/USDT\",\n        \"VET/USDT\"\n      ],\n      \"include_timeframes\": [\n        \"5m\",\n        \"15m\",\n        \"1h\"\n      ],\n      \"label_period_candles\": 2,\n      \"include_shifted_candles\": 2,\n      \"DI_threshold\": 0,\n      \"weight_factor\": 0.3,\n      \"principal_component_analysis\": false,\n      \"indicator_periods_candles\": [\n        7,\n        14,\n        28\n      ],\n      \"use_SVM_to_remove_outliers\": false,\n      \"plot_feature_importances\": 0,\n      \"shuffle_after_split\": false,\n      \"buffer_train_data_candles\": 0\n    },\n    \"data_split_parameters\": {\n      \"test_size\": 0,\n      \"random_state\": 42,\n      \"shuffle\": false\n    },\n    \"model_training_parameters\": {\n      \"n_estimators\": 500,\n      \"max_depth\": 5,\n      \"learning_rate\": 0.05,\n      \"subsample\": 0.8,\n      \"colsample_bytree\": 0.7,\n      \"reg_lambda\": 1,\n      \"min_child_weight\": 5\n    }\n  }\n}",
  "runInput": {
    "strategyName": "user_data/strategies/ll.py",
    "config": {
      "timeframe": "5m",
      "timerange": "20251109-20260207",
      "stake_amount": 50,
      "pairs": [
        "ETH/USDT",
        "BNB/USDT",
        "BTC/USDT",
        "SOL/USDT",
        "ADA/USDT"
      ],
      "max_open_trades": 5
    }
  }
}